Methodology
Explore application
Identify deep link vulnerability
Exploit deep link vulnerability
Identify JavaScript bridge vulnerability
Exploit JavaScript bridge vulnerability
Explore application
The application generates a random number when it starts up the first time. The goal of the application is to guess which number was generated with the least amount of tries.

Main screen
The Main application screen has an input field to enter your guess value. It also has a few buttons to perform various actions in the game.

Main Screen
You can enter a value between 1 and 100, if you enter the incorrect number, it will display an error message, and clear the input field.

Main Screen enter valueMain Screen incorrect value
If you enter the incorrect number more than 10 times, you will be presented with a message indicating that you have lost the game and also what the number was.

Main Screen - Game Over
If you enter the correct number, you will be presented with a message indicating that you have won the game, what the number was, and how many attempts you made.

Main Screen - Won
WebView screen
The WebView screen is used to load local and remote content. The screen is opened by using an Android intent, performing some validation and then deciding which resource to open.

Local content
When you tap the question mark icon on the Main screen, it will open the WebView screen, and render a local HTML file from the application assets.

This HTML file contains a message, the current system date and time, and also a hyperlink to a website.

Webiew Screen - Local
Remote content
When you tap the link found in the local HTML file rendered in the WebView, it will open the remote resource that it links to in the same WebView screen.

Webview Screen - Remote
Identify deep link vulnerability
First things first, let’s investigate the AndroidManifest.xml file to get an overview of the application entry points and, where potential deep links might exist.

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    android:versionCode="1"
    android:versionName="1.0"
    android:compileSdkVersion="34"
    android:compileSdkVersionCodename="14"
    package="com.mobilehackinglab.guessme"
    platformBuildVersionCode="34"
    platformBuildVersionName="14">
    <!-- ... -->
    <application
        android:theme="@style/Theme.Encoder"
        android:label="@string/app_name"
        android:icon="@mipmap/ic_launcher"
        android:debuggable="true"
        android:allowBackup="true"
        android:supportsRtl="true"
        android:extractNativeLibs="false"
        android:fullBackupContent="@xml/backup_rules"
        android:networkSecurityConfig="@xml/network_config"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:appComponentFactory="androidx.core.app.CoreComponentFactory"
        android:dataExtractionRules="@xml/data_extraction_rules">
        <activity
            android:name="com.mobilehackinglab.guessme.MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <activity
            android:name="com.mobilehackinglab.guessme.WebviewActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.VIEW"/>
                <category android:name="android.intent.category.DEFAULT"/>
                <category android:name="android.intent.category.BROWSABLE"/>
                <data
                    android:scheme="mhl"
                    android:host="mobilehackinglab"/>
            </intent-filter>
        </activity>
        <!-- ... -->
    </application>
</manifest>
Copy
For this section, we will focus on the WebviewActivity to see how it behaves and what we can do with it.

Using adb, we can start it up to see how it displays without us doing anything out of the ordinary. We will use the scheme defined in the AndroidManifest file:

mhl://mobilehackinglab

adb shell am start -a "android.intent.action.VIEW" -c "android.intent.category.BROWSABLE" -d "mhl://mobilehackinglab"
# Starting: Intent { act=android.intent.action.VIEW cat=[android.intent.category.BROWSABLE] dat=mhl://mobilehackinglab/... }
Copy
This worked; it opened the WebviewActivity and loaded a default webpage.

Webiew Screen - Local
Let’s take a look at the source code to find out what is happening when the WebviewActivity opens.

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_web);
    View findViewById = findViewById(R.id.webView);
    Intrinsics.checkNotNullExpressionValue(findViewById, "findViewById(...)");
    this.webView = (WebView) findViewById;
    WebView webView = this.webView;
    WebView webView2 = null;
    if (webView == null) {
        Intrinsics.throwUninitializedPropertyAccessException("webView");
        webView = null;
    }
    WebSettings webSettings = webView.getSettings();
    Intrinsics.checkNotNullExpressionValue(webSettings, "getSettings(...)");
    webSettings.setJavaScriptEnabled(true);
    WebView webView3 = this.webView;
    if (webView3 == null) {
        Intrinsics.throwUninitializedPropertyAccessException("webView");
        webView3 = null;
    }
    webView3.addJavascriptInterface(new MyJavaScriptInterface(), "AndroidBridge");
    WebView webView4 = this.webView;
    if (webView4 == null) {
        Intrinsics.throwUninitializedPropertyAccessException("webView");
        webView4 = null;
    }
    webView4.setWebViewClient(new WebViewClient());
    WebView webView5 = this.webView;
    if (webView5 == null) {
        Intrinsics.throwUninitializedPropertyAccessException("webView");
    } else {
        webView2 = webView5;
    }
    webView2.setWebChromeClient(new WebChromeClient());
    loadAssetIndex();
    handleDeepLink(getIntent());
}
Copy
There is a lot happening in this method, and it can be quite confusing. I believe that this was purposely done to make it more difficult to reverse engineer.

WebView initialization
This method initializes the WebView.

It enables JavaScript, adds a JavaScript bridge, and sets some clients to get access to some additional functionality.

For more information about the WebViewClient() and WebChromeClient() there is a post here.

WebView initial page load
This method uses the WebView to load a index.html file from the asset directory of the application.

private final void loadAssetIndex() {
    WebView webView = this.webView;
    if (webView == null) {
        Intrinsics.throwUninitializedPropertyAccessException("webView");
        webView = null;
    }
    webView.loadUrl("file:///android_asset/index.html");
}
Copy
This is the HTML which is rendered when you open the WebviewActivity without using a deep link.

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <p id="result">Thank you for visiting</p>

    <!-- Add a hyperlink with onclick event -->
    <a href="#" onclick="loadWebsite()">Visit MobileHackingLab</a>

    <script>
      function loadWebsite() {
        window.location.href = "https://www.mobilehackinglab.com/";
      }

      // Fetch and display the time when the page loads
      var result = AndroidBridge.getTime("date");
      var lines = result.split("\n");
      var timeVisited = lines[0];
      var fullMessage =
        "Thanks for playing the game\n\n Please visit mobilehackinglab.com for more! \n\nTime of visit: " +
        timeVisited;
      document.getElementById("result").innerText = fullMessage;
    </script>
  </body>
</html>
Copy
handleDeepLink()
private final void handleDeepLink(Intent intent) {
    Uri uri = intent != null ? intent.getData() : null;
    if (uri != null) {
        if (isValidDeepLink(uri)) {
            loadDeepLink(uri);
        } else {
            loadAssetIndex();
        }
    }
}
Copy
This method does a few checks:

Does the Intent indicate that it was opened by a deep link
Does that deep link contain a valid remote URL to open
Does the remote URL adhere to a predefined format
If all of these checks pass it will render the remote URL in the WebView.

isValidDeepLink(uri)
private final boolean isValidDeepLink(Uri uri) {
    if ((!Intrinsics.areEqual(uri.getScheme(), "mhl") && !Intrinsics.areEqual(uri.getScheme(), "https")) || !Intrinsics.areEqual(uri.getHost(), "mobilehackinglab")) {
        return false;
    }
    String queryParameter = uri.getQueryParameter("url");
    return queryParameter != null && StringsKt.endsWith$default(queryParameter, "mobilehackinglab.com", false, 2, (Object) null);
}
Copy
This method does a few checks:

Does the URI scheme and host match mhl://mobilehackinglab
Does the URI have a query string parameter url
Does the url parameter end in mobilehackinglab.com
